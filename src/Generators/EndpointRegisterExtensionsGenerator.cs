using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Generators;

[Generator]
public class EndpointRegisterExtensionsGenerator : ISourceGenerator
{
    private readonly Collector _collector = new();

    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => _collector);
    }

    public void Execute(GeneratorExecutionContext context)
    {
        // Retrieve the populated receiver
        if (!(context.SyntaxContextReceiver is Collector collector))
        {
            return;
        }

        if (collector.Partial is null)
        {
            throw new InvalidOperationException("Could not collect partial class to implement");
        }

        var @namespace = GetNamespace(collector.Partial);
        
        var endpointRegistrations = new StringBuilder();

        foreach (var endpointClass in collector.Endpoints)
        {
            endpointRegistrations.AppendLine($"{endpointClass.Identifier.ValueText}.Map(endpoints);");
        }

        var source = // lang=C#
$$""""
// <auto-generated/>

namespace {{@namespace}}; 

public static partial class EndpointRegistrationExtensions
{
    public static partial IEndpointRouteBuilder RegisterEndpoints(this IEndpointRouteBuilder endpoints)
    { 
        {{string.Join(Environment.NewLine, endpointRegistrations)}}
        return endpoints;
    }
}
"""";

        context.AddSource(nameof(EndpointRegisterExtensionsGenerator), SourceText.From(source, Encoding.UTF8));
    }

    private static string GetNamespace(SyntaxNode? node)
        => node switch
        {
            NamespaceDeclarationSyntax namespaceNode => namespaceNode.Name.ToString(),
            FileScopedNamespaceDeclarationSyntax fileScopedNamespaceNode => fileScopedNamespaceNode.Name.ToString(),
            { } => GetNamespace(node.Parent),
            _ => throw new InvalidOperationException("Could not find namespace")
        };

    // as seen on https://github.com/kant2002/SourceGeneratorsKit/
    // using a ISyntaxContextReceiver is one possible way, another, would be
    // to go through things in the GeneratorExecutionContext passed to the ISourceGenerator.Execute method
    private class Collector : ISyntaxContextReceiver
    {
        public ClassDeclarationSyntax? Partial { get; private set; }

        public List<ClassDeclarationSyntax> Endpoints { get; } = new();

        public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
        {
            if (context.Node is not ClassDeclarationSyntax @class) return;
            
            if (@class.Identifier.ValueText == "EndpointRegistrationExtensions")
            {
                Partial = @class;
            }
            else
            {
                var classSymbol = context.SemanticModel.GetDeclaredSymbol(@class);
                if (classSymbol?.AllInterfaces.Any(i => i.ToDisplayString().EndsWith("IEndpoint")) ?? false)
                {
                    Endpoints.Add(@class);
                }
            }
        }
    }
}