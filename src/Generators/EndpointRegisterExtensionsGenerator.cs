using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Generators;

[Generator]
public class EndpointRegisterExtensionsGenerator : ISourceGenerator
{
    private readonly Collector _collector = new();

    public void Initialize(GeneratorInitializationContext context)
        => context.RegisterForSyntaxNotifications(() => _collector);

    public void Execute(GeneratorExecutionContext context)
    {
        // Retrieve the populated receiver
        var collector = (Collector)context.SyntaxContextReceiver!;

        var @namespace = GetNamespace(collector.Partial);

        var endpointRegistrations = new StringBuilder();

        foreach (var endpointClass in collector.Endpoints)
        {
            endpointRegistrations.AppendLine($"{endpointClass.Identifier.ValueText}.Map(endpoints);");
        }

        var source = // lang=C#
            $$""""
// <auto-generated/>

namespace {{@namespace}}; 

public static partial class EndpointRegistrationExtensions
{
    public static partial IEndpointRouteBuilder RegisterEndpoints(this IEndpointRouteBuilder endpoints)
    { 
        {{endpointRegistrations}}
        return endpoints;
    }
}
"""";

        context.AddSource(
            $"{nameof(EndpointRegisterExtensionsGenerator)}.generated.cs", 
            SourceText.From(source, Encoding.UTF8));
    }

    private static string GetNamespace(SyntaxNode? node)
        => node switch
        {
            NamespaceDeclarationSyntax namespaceNode => namespaceNode.Name.ToString(),
            FileScopedNamespaceDeclarationSyntax fileScopedNamespaceNode => fileScopedNamespaceNode.Name.ToString(),
            { } => GetNamespace(node.Parent),
            _ => throw new InvalidOperationException("Could not find namespace")
        };

    // as seen on https://github.com/kant2002/SourceGeneratorsKit/
    // using a ISyntaxContextReceiver is one possible way, another, would be
    // to go through things in the GeneratorExecutionContext passed to the ISourceGenerator.Execute method
    private class Collector : ISyntaxContextReceiver
    {
        private readonly List<ClassDeclarationSyntax> _endpoints = new();
        private ClassDeclarationSyntax? _partial;
        
        public IReadOnlyCollection<ClassDeclarationSyntax> Endpoints => _endpoints;
        
        public ClassDeclarationSyntax Partial
            => _partial ?? throw new InvalidOperationException("Could not collect partial class to implement");

        public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
        {
            if (context.Node is not ClassDeclarationSyntax @class) return;

            if (@class.Identifier.ValueText == "EndpointRegistrationExtensions")
            {
                _partial = @class;
            }
            else
            {
                var classSymbol = context.SemanticModel.GetDeclaredSymbol(@class);
                if (classSymbol?.AllInterfaces.Any(i => i.ToDisplayString().EndsWith("IEndpoint")) ?? false)
                {
                    _endpoints.Add(@class);
                }
            }
        }
    }
}